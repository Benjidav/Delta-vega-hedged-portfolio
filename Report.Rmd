---
title: "<center> <h1>Report - Delta-Vega hedging project</h1> </center>"
author: "<center> <h4> Benjamin DAVILA </h4> </center>"
date: "<center> <h4> 12/12/2020 </h4> </center>"
output:
  pdf_document: default
  html_document: default
  word_document: default
---

```{r setup, include=FALSE}
library(knitr)
rm(list = ls())
opts_chunk$set(echo=TRUE, 
               warning=FALSE, 
               message=FALSE,
               cache = FALSE,
               include = TRUE,
               results = 'show',
               error = TRUE)
```

# Summary of the project
From the data provided (stock history, column B) in the file *Dataset*, we want to create the portfolio history of replication of a european call with maturity on **31/12/2018**, strike **K = 6**. To do that, we are going to use a synthetic replication portfolio formed from a stock, cash and another K6.5 european call option (to neutralize the effect of $\sigma$ on the price of the option).

Overview of the data

```{r, echo=FALSE}
library(numDeriv)
library(pracma)
library(ggplot2)
library("ggpubr")

dataset_heavy = read.csv2("C:\\Users\\benja\\OneDrive\\Documents\\Calibration\\Delta-gamma_hedged_portfolio\\Dataset.csv", header = TRUE)

head = head(dataset_heavy, 10)  
head = head[, -c(5, 6)]
print(head)
```

# I. Introduction

First, let's compute now the vector of maturity thanks to the following formula
$T_i = \frac{(T_{mat} - t_i)}{365}$.

Overview of the vector of maturities

```{r, echo = FALSE}
maturity.vector = function (date_serie, T)
{
  format = "%d/%m/%Y"
  date = rep(NA, length(date_serie))
  for (i in 1:length(date_serie))
  {
    date[i] = as.numeric(as.Date(T, format) - as.Date(date_serie[i], format))/365
  }
  return (date)
}
```


```{r, echo=FALSE}
dataset = dataset_heavy[,1:4]

date_serie = dataset[, 1]

stock_price = dataset[, 2]

obs_option_price_6 = dataset[, 3]

obs_option_price_6.5 = dataset[, 4]

# Maturity arbitrarily chosen
T = "31/12/2018"

T_vector = maturity.vector(date_serie, T)

head(T_vector, 10)

```

Let's visualize the value of the two options over time.

```{r, echo=FALSE, fig.align = "center"}
BS.OptionPricerEU <-function(S, K, T, r,volat, type="Call")
{
  d1 <- (log(S/K) + (r + 0.5*volat^2)*T) / (volat*sqrt(T))
  d2 <- d1 - volat*sqrt(T)
  if(type=="Call")
  {
    value <- S*pnorm(d1) - K*exp(-r*T)*pnorm(d2)
  }
  if(type=="Put")
  {
    value <- K*exp(-r*T)*pnorm(-d2) - S*pnorm(-d1)
  }
  return(value)
}

Vector.PriceOption = function (stock_price, K, T_vector, r, volat, type = "Call")
{
  price_option = rep(NA, length(T_vector))
  for (i in 1:length(T_vector))
  {
    price_option[i] = BS.OptionPricerEU(stock_price[i], K, T_vector[i], 0, volat, "Call")
  }
  return (price_option)
}

#Graphics
format = "%d/%m/%Y"

date = as.Date(date_serie, format)

#Data taken from the question 1
option_price_1 = Vector.PriceOption(stock_price, 6, T_vector, 0, 0.2, "Call")

obs_option_price_6 = dataset[, 3]

obs_option_price_6.5 = dataset[, 4]

ggplot(data = as.data.frame(obs_option_price_6),  aes(x = date)) + 
  geom_line(aes(y = obs_option_price_6, colour = "K6 Option")) +
  geom_line(aes(y = obs_option_price_6.5, color = "K6.5 Option")) +
  labs(title = "Option values over time",
       x = "Date",
       y = "Price") +
  scale_color_manual (name = "", values = c("K6 Option" = "red", "K6.5 Option" = "blue")) +
  scale_y_continuous(breaks = seq(0, 1.6, by = 0.2)) +
  theme(plot.title = element_text(hjust = 0.5, size = 15, face = "bold")) +
  theme(axis.title.x = element_text(hjust = 0.5, size = 12, face = "bold")) +
  theme(axis.title.y = element_text(hjust = 0.5, size = 12, face = "bold")) +
  theme(legend.position = "bottom")


```


```{r, echo = FALSE, fig.align = "center"}
option_price_2 = Vector.PriceOption(stock_price, 6.5, T_vector, 0, 0.2, "Call")

```

# II. Delta-Vega hedged portfolio with non constant volatility

In this part, we are going to build a synthetic delta-Vega hedged portfolio **formed by a stock, cash and a K6.5 call option**. The value of the portfolio **must be equal to the value of the option** to be replicated.
<br>

Overview of the principles of **delta-vega hedging** : 

![](C:\Users\benja\OneDrive\Images\Saved Pictures\vega.jpg)
We follow the same reasoning as for the previous project to find the following system : 

$$
\left\{
    \begin{array}{l}
        q_t + q'_t\delta'_t = \delta_t\qquad (1) \\
        q'_t = \frac{\nu_t}{\nu'_t\frac{\partial \sigma'}{\partial \sigma}}\qquad (2)\\
        q_tS_t + l_t + q'_tC'_t = C_t\qquad (3)
    \end{array}
\right.
$$
$$
\left\{
    \begin{array}{l}
        q_t = \delta_t - \delta'_t\frac{\nu_t}{\nu'_t\frac{\partial \sigma'}{\partial \sigma}}\qquad (1)\\
        q'_t =\frac{\nu_t}{\nu'_t\frac{\partial \sigma'}{\partial \sigma}}\qquad (2) \\
       l_t = C_t -  q'_tC'_t -  q_tS_t\qquad (3)
    \end{array}
\right.
$$

On the array above, we have different parameters. First, $\delta_t = N\big(d_1(t)\big)$  with $d_1(t) = \frac{1}{\sigma\sqrt{T_t}}\Big[ln\big(\frac{S_t}{K}\big) + \big(r + \frac{1}{2}\sigma^2\big)T_t\Big]$, $S_t$ the value of the stock and $T_t$ the vector of maturities. Furthermore, we have $\nu = \frac{\partial C}{\partial  \sigma} = S\sqrt{T}N'(d_1)$, and $\frac{\partial \sigma'}{\partial \sigma} = 
\frac{\sigma'_{t+1} - \sigma'_t}{\sigma_{t+1} - \sigma_t}$. Here, $\sigma_t$ and $\sigma'_t$ represent the volatilities of the K6 and K6.5 options. 

Besides, **we have another set of three parameters** : $q, l$ and $q'$ corresponding to the quantities of stock, cash and K6.5 option to be held in our portfolio. We can deduce the **general formula** to obtain the value of the portfolio over time : 

$V_t = V_{t - 1} + q_{t - 1}(S_t - S_{t - 1}) + q'_{t - 1}(C'_t - C'_{t - 1})$

In a first while, let's compute the **implied volatilities** of the K6 and K6.5 options over time using optimization algoritms (Newton-Raphson & bisection method) and get an overview of these

\

```{r, echo = FALSE}
#Optimization Algorithm

ImpliedVolat.binary.search = function (a, b, target_value, S, K, T, r, epsilon = 1e-4)
{
  c = -1
  fc = -1
  fa = target_value - BS.OptionPricerEU(S, K, T, r, a)
  fb = target_value - BS.OptionPricerEU(S, K, T, r, b)
  #We check that fa and fb did not get out of Df
  if (!is.nan(fa) && !is.nan(fb))
  {
    if (fa * fb>=0)
    {
      cat("pas de racine entre ", a," et ", b)
    }
    else
    {
      while (b-a >= epsilon && fc != 0)
      {
        c=(a+b)/2
        fc = target_value - BS.OptionPricerEU(S, K, T, r, c)
        if (!is.nan(fc))
        {
          if (fa * fc <=0)
          {
            b=c
          }
          else
          {
            a=c
          }
        }
        #Si fc is NaN
        else 
        {
          c = NaN
          break
        }
      }
    }
  }
  else
  {
    c = NaN
  }
  return (c)
}

ImpliedVolat.NewtonRaphson <- function(target_value, volat, S, K, T, r, n = 1000, PRECISION = 1.0e-4) 
{
  for (i in 1:n) 
  {
    price <- BS.OptionPricerEU(S, K, T, r, volat)
    vega <- bs_vega(S, K, T, r, volat)
    diff <- target_value - price  # our root
    if (abs(diff) < PRECISION) 
    {
      #cat("La valeur de la volatilité implicite approximée est de : " , volat)
      return(volat)
    }
    if (vega < PRECISION)
    {
      print("Itérations stoppées car Vega est devenu trop faible")
      return (volat)
    }
    volat <- volat + diff/vega # f(x) / f'(x)
  }
  print('Too many iterations in method')
}    

#Relevant function to compute f'(x) from BS function C(volat)
bs_vega <- function(S,K,T,r,volat,q=0.0, type = "Call") 
{
  d1 <- (log(S/K)+(r+(volat*volat)/2.)*T)/(volat*sqrt(T))
  return(S * sqrt(T)*dnorm(d1))
}

Vector.bs_vega  <- function(stock_price, K, T_vector, d1_vector, q=0.0, type = "Call") 
{
  vector_vega = rep(NA, length(d1_vector))
  for (i in 1:length(d1_vector))
  {
    if (!is.na(d1_vector[i]))
    {
      vector_vega[i] = stock_price[i] * sqrt(T_vector[i])*dnorm(d1_vector[i])
    }
  }
  return(vector_vega)
}

display_func = function (func, a, b)
{
  curve (func, from = a, to = b, type = "l", xlab = "Valeur de x", ylab = "F(x)")
  abline(h=0, col="red", lty=1, lwd=2)
}

func = function (x)
{
  x^2 + 1
}

BS.parameters = function (S, K, T, r)
{
  list = list ("S" = S, "K" = K,"T" = T, "r" = r)
  return (list)
}

#f(a) * f(b) <= 0 is Necessary to start the Algorithm
binary.search = function (f, a, b, epsilon = 1e-5)
{
  c = -1
  fc = -1
  fa = f(a)
  fb = f(b)
  if (fa * fb>=0)
  {
    cat("pas de racine entre ", a," et ", b)
  }
  else
  {
    while (b-a >= epsilon && fc != 0)
    {
      c=(a+b)/2
      fc = f(c)
      if (fa * fc <=0)
      {
        b=c
      }
      else
      {
        a=c
      }
    }
    cat("Une racine possible est  : ", c)
    return (c)
  }
}

newton.raphson = function(f, a, tol = 1e-5, n = 1000) 
{
  require(numDeriv) # Package for computing f'(x)
  
  x0 = a # Set start value to supplied lower bound
  k = n # Initialize for iteration results
  res = 0
  # Check the upper and lower bounds to see if approximations result in 0
  fx0 = f(x0)
  
  if (fx0 == 0.0) 
  {
    return(x0)
  }
  
  for (i in 1:n) 
  {
    dx = genD(func = f, x = x0)$D[1] # First-order derivative f'(x0)
    x1 = x0 - (f(x0) / dx) # Calculate next value x1
    k[i] = x1 # Store x1
    # Once the difference between x0 and x1 becomes sufficiently small, output the results.
    if (!is.nan(x1))
    {
      if (abs(x1 - x0) < tol) 
      {
        root.approx = tail(k, n=1)
        res = list('root approximation' = root.approx, 'iterations' = k)
        return(res)
      }
      # If Newton-Raphson has not yet reached convergence set x1 as x0 and continue
      x0 = x1
    }
    #Si x1 est NaN --> on stoppe l'algo
    else
    {
      print("L'algorithme a été stoppé à cause d'une forme inderterminée")
      break
    }
  }
  #We display that only if there is no error and if the number of iterations  is N
  if (i == n)
  {
    print('Too many iterations in method')
  }
}

```


```{r, echo = FALSE}

Vector.d1 = function (S, K, r, volat, T_vector)
{
  vector_d1 <- rep(NA, length(T_vector))
  for (i in 1:length(T_vector))
  {
    vector_d1[i] = (log(S[i]/K) + (r + 0.5*volat^2)*T_vector[i]) / (volat*sqrt(T_vector[i]))
  }
  return (vector_d1)
}

Vector.d1.VolatVary = function (S, K, r, volat, T_vector)
{
  vector_d1 <- rep(NA, length(volat))
  for (i in 1:length(volat))
  {
    if (!is.na(volat[i]))
    {
      vector_d1[i] = (log(S[i]/K) + (r + 0.5*volat[i]^2)*T_vector[i]) / (volat[i]*sqrt(T_vector[i]))
    }
  }
  return (vector_d1)
}

Vector.DeltaOption = function (vector_d1)
{
  vector_delta <- rep(NA,length(vector_d1))
  for (i in 1:length(vector_d1))
  {
    #delta[i] = N(d1[i])
    vector_delta[i] = pnorm(vector_d1[i])
  }
  return (vector_delta)
}

```


```{r, echo = FALSE}
#------------------------------Question 4 : Historical Implied Volatility of two options

Historical.ImpliedVolat.NewtonRaphson = function (option_price, volat, stock_price, K, T_vector, r)
{
  hist_Impliedvolat = rep(NA, length(option_price))
  for (i in 1:length(option_price))
  {
    if(!is.na(option_price[i]))
    {
      hist_Impliedvolat[i] = ImpliedVolat.NewtonRaphson(option_price[i], volat, stock_price[i], K, T_vector[i], r)
    }
  }
  return (hist_Impliedvolat)
}

Historical.ImpliedVolat.binary.search = function (a, b, option_price, stock_price, K, T_vector, r)
{
  hist_Impliedvolat = rep(NA, length(option_price))
  for (i in 1:length(option_price))
  {
    if(!is.na(option_price[i]))
    {
      hist_Impliedvolat[i] = ImpliedVolat.binary.search(a, b, option_price[i], stock_price[i], K, T_vector[i], r)
    }
    if (is.nan(hist_Impliedvolat[i])) stop ("fa and fb got out of Df")
  }
  return (hist_Impliedvolat)
}

#Question 4 : Historical Implied Volatility of two Options
hist_volat_option1 = Historical.ImpliedVolat.NewtonRaphson(obs_option_price_6, 1, stock_price, 6, T_vector, 0)

#The results shows that the volatility can vary over time

hist_volat_option2 = Historical.ImpliedVolat.NewtonRaphson(obs_option_price_6.5, 1, stock_price, 6.5, T_vector, 0)

d1_vect_Opt6 = Vector.d1.VolatVary(stock_price, 6, 0, hist_volat_option1, T_vector)

delta_serie_Opt6 = Vector.DeltaOption(d1_vect_Opt6)

#Same for the other option K = 6.5
d1_vect_Opt6.5 = Vector.d1.VolatVary(stock_price, 6.5, 0, hist_volat_option2, T_vector)

delta_serie_Opt6.5 = Vector.DeltaOption(d1_vect_Opt6.5)

```


```{r, echo = FALSE}
a = ggplot(as.data.frame(hist_volat_option1), aes(x = date)) + 
  geom_line(aes(y = hist_volat_option1, colour = "Historical volatility of the K6 Option")) + 
  geom_line(aes(y = hist_volat_option2, colour = "Historical volatility of the K6.5 Option")) +
  scale_color_manual(name = "", values = c("Historical volatility of the K6 Option" = "red", 
                                                  "Historical volatility of the K6.5 Option" = "blue")) +
  scale_y_continuous(breaks = seq(0, 0.5, 0.05)) +
  labs(title = "Historical volatilities of the two options") + 
  xlab("Date") + ylab("Value") +
  theme(plot.title = element_text(hjust = 0.5, size = 15, face = "bold")) +
  theme(axis.title.x = element_text(hjust = 0.5, size = 12, face = "bold")) +
  theme(axis.title.y = element_text(hjust = 0.5, size = 12, face = "bold"))
a + theme(legend.position = "bottom")

```
\

Now, let's compute the $\nu_t$ of the two options (thanks to the formula mentioned above) and get an overview of these

```{r, echo = FALSE}
Vector.bs_vega  <- function(stock_price, K, T_vector, d1_vector, q=0.0, type = "Call") 
{
  vector_vega = rep(NA, length(d1_vector))
  for (i in 1:length(d1_vector))
  {
    if (!is.na(d1_vector[i]))
    {
      vector_vega[i] = stock_price[i] * sqrt(T_vector[i])*dnorm(d1_vector[i])
    }
  }
  return(vector_vega)
}

#Computation of vega'option 1 & option 2
vega_Opt6 = Vector.bs_vega(stock_price, 6, T_vector, d1_vect_Opt6, q=0.0, type = "Call")

vega_Opt6.5 = Vector.bs_vega(stock_price, 6.5, T_vector, d1_vect_Opt6.5, q=0.0, type = "Call")

head(vega_Opt6, 10)

head(vega_Opt6.5, 10)
```
Then, we have to compute the ratio of volatility increments 
$\frac{\partial \sigma'}{\partial \sigma} = \frac{\sigma'_{t+1} - \sigma'_t}{\sigma_{t+1} - \sigma_t}$
.As a reminder, we have to consider the following formula : $\frac{\partial C'}{\partial \sigma} = \frac{\partial C'}{\partial \sigma'}\frac{\partial \sigma'}{\partial \sigma}$


```{r, echo = FALSE}
compute_increments = function (hist_vector)
{
 increment_vector = rep(NA, length(hist_vector))
  for (i in 2:length(increment_vector))
  {
    if(!is.na(hist_vector[i - 1]))
    {
      increment_vector[i] = hist_vector[i] - hist_vector[i - 1]
    }
  }
  return (increment_vector)
}

#Volatility increments : sigma & sigma'
volat_increment_option1 = compute_increments(hist_volat_option1)

volat_increment_option2 = compute_increments(hist_volat_option2)

```




```{r, echo = FALSE}

compute_derived_sigma = function (increment_hist_opt1, increment_hist_opt2)
{
  derived_sigma = rep(NA, length(increment_hist_opt1))
  for (i in 2:length(derived_sigma))
  {
    if(!is.na(increment_hist_opt1[i]) & !is.na(increment_hist_opt2[i]))
    {
      derived_sigma[i] = increment_hist_opt2[i]/increment_hist_opt1[i]
    }
  }
  return (derived_sigma)
}

compute_crossed_vega = function (vega_option, derived_sigma)
{
  crossed_vega = rep(NA, length(vega_option))
  for (i in 1:length(crossed_vega))
  {
    if(!is.na(vega_option[i]) & !is.na(derived_sigma[i]))
    {
      crossed_vega[i] = vega_option[i] * derived_sigma[i]
    }
  }
  return (crossed_vega)
}

#Computing the dsigma'/dsigma
derived_sigma = compute_derived_sigma(volat_increment_option1, volat_increment_option2)

crossed_vega_option2 = compute_crossed_vega(vega_Opt6.5, derived_sigma)
```


Now, let's compute the value of $q, l$ and $q'$ (reminder: the first three values can't be computed)

```{r, echo = FALSE}
Vector.PrmVega = function (vega_serie_1, vega_serie_2, delta_serie_1, delta_serie_2, option_price_Opts6, option_price_Opts6.5, crossed_vega_Opt2, stock_price)
{
  q_option_2 = rep(NA, length(option_price_Opts6))
  q_stock = rep(NA, length(option_price_Opts6))
  l_cash = rep(NA, length(option_price_Opts6))
  for (i in 1:length(option_price_Opts6))
  {
    if (!is.na(derived_sigma[i]))
    {
      #q'(i)= vega(i)/(vega'(i) * derived_sigma)
      q_option_2[i] = vega_serie_1[i] / (crossed_vega_Opt2[i])
      #q(i)= delta(i) - delta'(i) * (vega'(i) * derived_sigma)
      q_stock[i] = delta_serie_1[i] - delta_serie_2[i] * (vega_serie_1[i]/crossed_vega_Opt2[i])
      #q'(i) = C(i) - q''(i) * C''(i) - q(i) * stock (i)
      l_cash[i] = option_price_Opts6[i] - q_option_2[i] * option_price_Opts6.5[i] - q_stock[i] * stock_price[i]
    }
  }
  list_prm = list(q_option_2, l_cash, q_stock)
  names(list_prm) = c("q_option_2",  "l_cash", "q_stock")
  return (list_prm)
}

#list of parameters
list_prm_Opt6_vega = as.data.frame(Vector.PrmVega(vega_Opt6, vega_Opt6.5, delta_serie_Opt6, 
                                                  delta_serie_Opt6.5, obs_option_price_6, obs_option_price_6.5, crossed_vega_option2,
                                                  stock_price))
head(list_prm_Opt6_vega, 10)

```

Finally, we use the previous parameters and the iteration process mentioned above in order to build the history of the portfolio of replication : 

\

```{r, echo = FALSE}
Vector.PrmGamma = function (gamma_serie_1, gamma_serie_2, delta_serie_1, delta_serie_2, option_price_1, option_price_2, stock_price)
{
  q_option_2 = rep(NA, length(gamma_serie_1))
  q_stock = rep(NA, length(gamma_serie_1))
  q_cash = rep(NA, length(gamma_serie_1))
  for (i in 1:length(gamma_serie_1))
  {
    if (!is.na(gamma_serie_1[i]))
    {
      #q''(i)= G(i)/G''(i)
      q_option_2[i] = gamma_serie_1[i] / gamma_serie_2[i]
      #q(i)= delta(i) - q''(i) * delta''(i)
      q_stock[i] = delta_serie_1[i] - q_option_2[i] * delta_serie_2[i]
      #q'(i) = C(i) - q''(i) * C''(i) - q(i) * delta (i)
      q_cash[i] = option_price_1[i] - q_option_2[i] * option_price_2[i] - q_stock[i] * stock_price[i]
    }
  }
  list_prm = list(q_option_2, q_cash, q_stock)
  names(list_prm) = c("q_option_2",  "q_cash", "q_stock")
  return (list_prm)
}

Vector.GammaOption = function (vector_d1, stock_price, volat, T_vector)
{
  vector_gamma <- rep(NA,length(vector_d1))
  for (i in 1:length(vector_d1))
  {
    #Gamma[i] = N'(d1[i])/S*volat*sqrt(t)
    vector_gamma[i] = dnorm(vector_d1[i])/(stock_price[i] * volat * sqrt(T_vector[i]))
  }
  return (vector_gamma)
}

Vector.GammaOption.VolatVary = function (vector_d1, stock_price, volat, T_vector)
{
  vector_gamma <- rep(NA,length(vector_d1))
  for (i in 1:length(vector_d1))
  {
    #Gamma[i] = N'(d1[i])/S*volat*sqrt(t)
    if (!is.na(vector_d1[i]))
    { 
      vector_gamma[i] = dnorm(vector_d1[i])/(stock_price[i] * volat[i] * sqrt(T_vector[i]))
    }
  }
  return (vector_gamma)
}

option_price_1 = Vector.PriceOption(stock_price, 6, T_vector, 0, 0.2, "Call")

d1_vect_1 = Vector.d1(stock_price, 6, 0, 0.2, T_vector)

delta_serie_1 = Vector.DeltaOption(d1_vect_1)
gamma_serie_1 = Vector.GammaOption(d1_vect_1, stock_price, 0.2, T_vector)

#Greeks of the second Option 
d1_vect_2 = Vector.d1(stock_price, 6.5, 0, 0.2, T_vector)

delta_serie_2 = Vector.DeltaOption(d1_vect_2)

gamma_serie_2 = Vector.GammaOption(d1_vect_2, stock_price, 0.2, T_vector)

option_price_2 = Vector.PriceOption(stock_price, 6.5, T_vector, 0, 0.2, "Call")

#list of parameters
list_prm = as.data.frame(Vector.PrmGamma(gamma_serie_1, gamma_serie_2, delta_serie_1, delta_serie_2, option_price_1, option_price_2, stock_price))

```




```{r, echo=FALSE, fig.align="center"}

#---------------------------------Question 6 : Delta-vega hedging-------------------------------------

pf.deltaVega_hedging = function (price_option_1, price_option_2, stock_price, list_prm_vega)
{
  portfolio = rep(NA, length(price_option_1))
  j = 1
  #V0 = C0 en vérifiant que la premiere valeur est pas NA
  if (is.na(list_prm_vega[1, 1]))
  {
    while (is.na(list_prm_vega[j, 1]))
    {
      j = j + 1
    }
    #the last +1 is here because of q' : quantity of the second option
    portfolio[j] = price_option_1[j]
  }
  else 
  {
    portfolio[1] = price_option_1[1]
  }
  #the last +1 is here because of q' : quantity of the second option
  for (i in (j + 1):length(portfolio))
  {
    if (!is.na(list_prm_vega[i - 1, 1]))
    {
      portfolio[i] = portfolio[i - 1] + list_prm_vega[i - 1, 3] * (stock_price[i] - stock_price[i - 1]) + list_prm[i - 1, 1] * (price_option_2[i] - price_option_2[i - 1])
    }
  }
  return (portfolio)
}

#Delta-Vega Hedging
pf_Delta_Vega = pf.deltaVega_hedging(obs_option_price_6, obs_option_price_6.5, stock_price, list_prm_Opt6_vega)

```




```{r, echo=FALSE}

#Delta-vega
pf_DeltaVega_Replication_Opt6_graphe <- ggplot(as.data.frame(pf_Delta_Vega), aes(x = date)) + geom_line(aes(y = pf_Delta_Vega, colour = "Delta-vega hedged pf")) + 
geom_line(aes(y = obs_option_price_6, colour="K6 Option")) +
scale_color_manual(name = "", values = c("Delta-vega hedged pf" = "black", "K6 Option" = "blue")) +
labs(title = "Delta-Vega Hedging of the K6 Option") + xlab("") + ylab("Value") +
xlab("Date") + ylab("Value") +
  theme(plot.title = element_text(hjust = 0.5, size = 15, face = "bold")) +
  theme(axis.title.x = element_text(hjust = 0.5, size = 12, face = "bold")) +
  theme(axis.title.y = element_text(hjust = 0.5, size = 12, face = "bold"))
 

pf_DeltaVega_Replication_Opt6_graphe + theme(legend.position = "bottom")
```


**Interpretation** : As we can see on the chart above, the two times series are almost equal over time, especially from March, 2018. We can deduce that the hedge method is really efficient. To improve the quality of the replication, we could add an other call option to the portfolio to build a delta-gamma-vega hedged portfolio.



```{r, echo=FALSE}

 


```



